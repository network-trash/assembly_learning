一、汇编语言的基础知识
	1.数据表示：
		（1）二进制、十六进制与十进制的转换，注意高位低位的选取；
		（2）BCD码的表示（了解）、ASCLL码（表格的记忆）、Unicode；
		（3）补码的运算：负数的补码是取反+1，这里的取反是指的全部取反，包括首位
	2.Intel处理器
		（1）8086处理器：16位的数据总线、20位的地址总线，因此支持1MB的主存储量（1位相当于1B）；8088处理器（设计目的是为了方便与8位的外部设备连接，但是语言系统与8086相同）
		（2）80286（16MB）、80386（4GB）、Pentium系列
	3.8086的功能结构以及寄存器
		（1）段寄存器(seg)
			①CS(Code Segment):通常与IP（存放着偏移地址）搭配，实现取指令的操作
			②DS(Data Segment):利用各种寻址方式来找到偏移地址。
			③SS(Stack Segment):通常与SP搭配来实现
			④ES(Extra Segment)：默认的是串操作的目的操作数所在地方的段地址。
		通用寄存器：(reg)（可以用来保存数据、暂存运算结果、存放存储器地址、作为变量的指针）
		（2）数据寄存器
			①AX(Accumulator):累加器
			②BX(Base):基址存储器
			③CX(Counter):计数器
			④DX(Data):数据寄存器
		（3）地址寄存器
			①SP(Stack Pointer):堆栈指针寄存器，专门指向程序堆栈顶部的数据，在涉及堆栈运算时会自动增加和减少。
			②BP(Base Pointer):基址指针寄存器，默认指向程序堆栈区域的数据，用于子程序访问通过堆栈传递的参数和局部变量。
			③SI(Source Index):源变址寄存器，指向源操作数
			④DI(Destination):目的变址寄存器，指向目的操作数
		（4）专用寄存器
			①IP:指针寄存器，只用来记录将要执行指令的主存地址。
			②标志寄存器：保存指令执行的辅助信息。
	4.数据存储格式：小端模式，也就是低对低，高对高，数据的低位对应着地址的低位也对应着字节的低字节。
	5.存储器的分段管理模式（由于地址是20位的，而本身的存储器是16位的）：
		采用的是段基地址加段内偏移地址的方式，其中段基地址一定是xxxx0H的格式，因此将最后一位回缩4位就可以储存在段寄存器里面，这样就可以访问全部的地址，是先进行平移，然后将其加上偏移的地址就可以得到最终的地址。
	6.寻址方式
		（1）立即数寻址方式（imm）（常用于给寄存器赋值）
		（2）寄存器寻址方式（速度快，常用）
		（3）存储器寻址方式
			①直接寻址方式：默认是从DS区域取东西，也可以超越到ES、CS、SS。
			②寄存器间接寻址方式：从si、di、bx中取东西，默认还是DS，可以超越。
			③寄存器相对寻址方式：寄存器再加上个地址，注意bp默认的是SS段，其他的如BX、SI、DI都是DS
			④基址变址寻址方式：基址加上变址
			⑤相对基址变址寻址方式：上面那个玩意再加上个数。
二、基本指令集（https://mudongliang.github.io/x86/）
	1.数据传送类指令（src:源地址 dest:目的地址）(r 通用寄存器 m 内存 imm 代表立即数 r8 代表8位通用寄存器 m8 代表8位内存 imm8 代表8位立即数)
		（1）通用数据传送指令
			① mov:不允许段寄存器与段寄存器之间相互传送数据、立即数如果是字母开头的话需要前导一个0、不允许立即数传送到段寄存器、不允许主存和主存之间相互传送数据
			注：由于指定的寄存器有着明确的字节或者字类型，所以对应的立即数必须表明，如果容易混淆，则需要加入汇编操作符byte ptr（字节）word ptr（字）
			注：虽然存在reg/mem向cs段寄存器传递数据的指令，但是不允许执行，容易造成混乱
			②XCHG: xchg reg, reg/mem.相互调换数据
			③XLAT: xlat ; al<-ds:[bx+al]  (无显示操作数，被称为隐含寻址方式)
		（2）堆栈操作指令：堆栈是一块“先进后出”的主存区域，栈顶是地址小端，数据是逐渐往下放的，在这个过程中，栈指针也在向下移动，只能操作字单位。
			①push r16/m16/seg  ; sp<-sp-2,ss:[sp]<-r16/m16/seg 
			②pop r16/m16/seg   ; 与上式相反
		（3）标志传送指令
			空 空 空 空 OF DF IF TF SF ZF 空 AF 空 PF 空 CF
			①lahf\sahf:分别指的是将低字节传递进入AH，和反向操作。
			②pushf\popf:分别指的是将标志器的内容压入栈和从栈中弹出。
			③标志位操作：可以用来对于CF\DF\IF来修改。
		（4）地址传送指令
			①lea r16, mem	将存储器操作数的有效地址给指定的寄存器
			②lds r16, mem ;r16 <- mem,ds <- mem
			③les r16, mem ;r16 <- mem,es <- mem
		注：除了以标志为目的操作数的标志传送指令，其他的都不变更标志位。
	2.算术运算类指令
		（1）状态标志
			①CF(carry flag):进位标志 最高有效位产生进位时为1,否则为0.
			②OF(overflow flag)
			③ZF(Zero flag):如果运算结果为0，那么ZF=1.
			④PF(Parity flag):奇数偶数检验标志，检验最低字节中"1"的个数是奇数还是偶数
			⑤AF(auxiliary carry flag):辅助进位标志 运算时,第3位向第4位产生进位时为1,否则为0.
			⑥SF(sign Flag):符号标志 记录运算结果的符号,结果负时为1. 
			⑦DF(direcion flag):方向标志 用于串处理.DF=1时,每次操作后使SI和DI减小.DF=0时则增大. 
			⑧IF(interrupt flag):中断标志 IF=1时,允许CPU响应可屏蔽中断,否则关闭中断. 
			⑨TF(trap flag):陷阱标志 用于调试单步操作
		（2）加法指令
			add reg imm/reg/mem; add mem imm/reg; reg/mem<-imm/reg/mem
			adc reg imm/reg/mem; adc mem imm/reg; reg/mem<-imm/reg/mem+cf
			inc reg/mem; reg/mem++
		（3）减法指令
			①sub,sbb,dec 与加法对应
			②neg 求补
			③cmp reg,imm/reg/mem; cmp mem,imm/reg;不改变目的操作数，只是改变标志位。
		（4）乘法指令
			①mul r8/m8; ax<-al*r8/m8
			 mul r16/m16; dx.ax<-ax*r16/m16
			②imul r8/m8;
			 imul r16/m16;
			注：乘法指令只对于OF\CF有影响，其他的没有定义，还有可能对于SF产生影响，
				判断高一半是否有有效数字。OF/CF = 1,则是有效的。 
		（5）除法指令
			①div r8/m8; al<-ax/(r8/m8)的商 ah<-ax/(r8/m8)的余数
			②idiv
			注：除了以标志为目的操作数的标志传送指令，其他的都不变更标志位。对标志位没有定义，但是可以溢出，
				没写的部分表示一样，也可以对r16/m16操作，都是高位存余数，低位存商。
		（6）符号扩展指令:cbw扩展8位的，cwd扩展16位的；常常用于扩展被除数，因为被除数的位数可能不符合要求
	3.位操作类指令
		（1）逻辑运算指令（都是根据结果设置SF\ZF\PF的状态，规定CF\OF为0，对于AF未定义）
			①and dest,src; dest<-dest&&src
			②or
			③xor
			④not reg/mem
			⑤test 和and一样，但是不改变操作数，只改变状态标志
		（2）移位指令
			①shl reg/mem,1/cl:逻辑左移，最高位进入cf
			②shr reg/mem,1/cl:逻辑右移，最低位进入cf
			③sal reg/mem,1/cl:和shl一样
			④sar reg/mem,1/cl:算数右移，最低位进入cf（就是）
		（3）循环移位指令
	4.控制转移类指令
		（1）无条件转移指令（直接跳转至标号位置）
		（2）条件转移指令（利用标志位判断）
		（3）循环指令（学习模板）
		（4）子程序指令：让系统进入到另一个子程序中去，进而实现从主程序到子程序的跳转。
		（5）中断指令
	5.处理机控制类指令
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			①
			②
			③
			④
			⑤
			⑥